<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GINE</title>
  
  <subtitle>good is not enough</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.gine.me/"/>
  <updated>2018-08-30T07:33:57.000Z</updated>
  <id>https://blog.gine.me/</id>
  
  <author>
    <name>Mayne</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟环境自动化</title>
    <link href="https://blog.gine.me/2018/08/30/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://blog.gine.me/2018/08/30/虚拟环境自动化/</id>
    <published>2018-08-30T07:27:32.000Z</published>
    <updated>2018-08-30T07:33:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目虚拟环境自动化"><a href="#项目虚拟环境自动化" class="headerlink" title="项目虚拟环境自动化"></a>项目虚拟环境自动化</h1><ul><li>使用 <code>pipenv</code> 为每个项目创建虚拟环境</li><li>使用 <code>autoenv</code> 在进入项目根目录的时候自动激活虚拟环境</li></ul><h2 id="安装-autoenv"><a href="#安装-autoenv" class="headerlink" title="安装 autoenv"></a>安装 autoenv</h2><pre><code>$ brew install autoenv$ echo &quot;source $(brew --prefix autoenv)/activate.sh&quot; &gt;&gt; ~/.bash_profile# 如果是zsh bash_profile 换成 zshrc</code></pre><h2 id="autoenv-的使用方法"><a href="#autoenv-的使用方法" class="headerlink" title="autoenv 的使用方法"></a>autoenv 的使用方法</h2><p>在项目根目录下建立 <code>.env</code> 文件，文件的内容是一个 shell 命令， 用来激活虚拟环境。</p><p>例如我有一个 <code>test</code> 的虚拟环境，那么在 <code>test</code> 的根目录下建立 <code>.env</code> 内容如下</p><pre><code># .envpipenv shell</code></pre><h2 id="统一为已有虚拟环境创建-env-文件"><a href="#统一为已有虚拟环境创建-env-文件" class="headerlink" title="统一为已有虚拟环境创建 .env 文件"></a>统一为已有虚拟环境创建 .env 文件</h2><p>已经使用 <code>pipenv</code> 有一段时间了，工作区也积累了很多虚拟环境。用以下脚本为每个虚拟环境统一创建 <code>.env</code> 文件</p><p>在虚拟环境目录下，例如 <code>/Users/mayne/.local/share/virtualenvs</code> 执行下面的 <code>python</code> 脚本</p><pre><code>import osall_env = os.listdir(&apos;.&apos;)for env in all_env:    project_info_file = os.path.join(env, &apos;.project&apos;)    if os.path.exists(project_info_file):        with open(project_info_file) as f:            env_dir = f.read()            env_script = &apos;pipenv shell&apos;            env_script_file = os.path.join(env_dir, &apos;.env&apos;)            with open(env_script_file, &apos;+w&apos;) as f:                f.write(env_script)                print(&apos;{} 已创建.env文件&apos;.format(env_dir))</code></pre><ul><li><code>pipenv</code> 在新版中才引入 .project 这个文件，老的虚拟环境可能没有这个文件，也就无法自动创建 <code>.env</code> ，需要手动创建。</li></ul><p>这样在进入项目目录的时候就会自动激活虚拟环境了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;项目虚拟环境自动化&quot;&gt;&lt;a href=&quot;#项目虚拟环境自动化&quot; class=&quot;headerlink&quot; title=&quot;项目虚拟环境自动化&quot;&gt;&lt;/a&gt;项目虚拟环境自动化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;pipenv&lt;/code&gt;
        
      
    
    </summary>
    
    
      <category term="pipenv" scheme="https://blog.gine.me/tags/pipenv/"/>
    
      <category term="自动化" scheme="https://blog.gine.me/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Django如何在model层获取当前用户信息</title>
    <link href="https://blog.gine.me/2018/08/30/Django%E5%A6%82%E4%BD%95%E5%9C%A8model%E5%B1%82%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://blog.gine.me/2018/08/30/Django如何在model层获取当前用户信息/</id>
    <published>2018-08-30T06:22:58.000Z</published>
    <updated>2018-08-30T07:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="django-如何在model层获取到当前用户的信息"><a href="#django-如何在model层获取到当前用户的信息" class="headerlink" title="django 如何在model层获取到当前用户的信息"></a>django 如何在model层获取到当前用户的信息</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>要做一个统一的log模块，用来存储模型实例的变更记录。既然是log，就要知道是谁操作的。在django中分为view层和model层。在view层面可以很方面的获取到request信息，但是在model层是获取不到。</p><p>搜索了一番，发现了很做骚操作，简要地记录一下</p><p>关键词: <code>django get current user in model/signal</code></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>也是最常见的方法，中间件中获取request信息，保存在当前线程中</p><pre><code>from threading import current_threadfrom django.utils.deprecation import MiddlewareMixin_requests = {}def current_request():    return _requests.get(current_thread().ident, None)class RequestMiddleware(MiddlewareMixin):    def process_request(self, request):        _requests[current_thread().ident] = request    def process_response(self, request, response):        # when response is ready, request should be flushed        _requests.pop(current_thread().ident, None)        return response    def process_exception(self, request, exception):        # if an exception has happened, request should be flushed too         _requests.pop(current_thread().ident, None)</code></pre><p>参见</p><p><a href="https://stackoverflow.com/a/36328564/5808718" target="_blank" rel="noopener">Django: Get current user in model save</a></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在pre_save的时候，从堆栈信息中信息中获取request对象。</p><pre><code>from django.db.models.signals import pre_savefrom django.dispatch import receiver@receiver(pre_save)def my_callback(sender, **kwargs):    import inspect    for frame_record in inspect.stack():        if frame_record[3]==&apos;get_response&apos;:            request = frame_record[0].f_locals[&apos;request&apos;]            break    else:        request = None    ...</code></pre><p>参见</p><p><a href="https://stackoverflow.com/a/8874383" target="_blank" rel="noopener">Get current user log in signal in Django</a></p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>单例</p><p>中间件中获取到请求用户，存储在单例中。线程安全？？？</p><p><a href="https://stackoverflow.com/a/7469395" target="_blank" rel="noopener">Get current user log in signal in Django</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;django-如何在model层获取到当前用户的信息&quot;&gt;&lt;a href=&quot;#django-如何在model层获取到当前用户的信息&quot; class=&quot;headerlink&quot; title=&quot;django 如何在model层获取到当前用户的信息&quot;&gt;&lt;/a&gt;django
        
      
    
    </summary>
    
    
      <category term="django" scheme="https://blog.gine.me/tags/django/"/>
    
      <category term="中间件" scheme="https://blog.gine.me/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>个人信息管理</title>
    <link href="https://blog.gine.me/2018/08/27/%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.gine.me/2018/08/27/个人信息管理/</id>
    <published>2018-08-27T07:17:23.000Z</published>
    <updated>2018-08-30T08:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人信息管理"><a href="#个人信息管理" class="headerlink" title="个人信息管理"></a>个人信息管理</h1><p>关于个人信息管理流程的思考</p><h2 id="知识的获取"><a href="#知识的获取" class="headerlink" title="知识的获取"></a>知识的获取</h2><p>信息来源的问题，日常生活接触到的事物，有意义的无意义的。信息是知识的超集，信息中包含一些杂音。我们会被动的接受许多信息，而这些信息很多是无意义的，需要对其过滤。</p><p>获取知识的形式</p><ul><li>被动获取，被其他信息源告知，这个信息可能是包含了表面层次的 <code>词汇</code></li><li>主动获取，获取信息后，深入查找其相关信息包含关于这个<code>词汇</code>的 <code>释义</code>。这种信息，是多个 <code>词汇</code> 汇聚后思考形成的 <code>想法</code></li><li>个人输出，通过内在的沉淀，对某个知识有深入的了解，最后形成关于该知识的 知识体系。</li></ul><p>过滤信息</p><ul><li>把控信息的源头，RSS订阅 从可信的人那里获取信息，防止被铺天盖地的广告和辣鸡信息淹没</li><li>个人筛选，个人会倾向于选取自己感兴趣的信息。</li></ul><h2 id="知识的管理"><a href="#知识的管理" class="headerlink" title="知识的管理"></a>知识的管理</h2><p>首先日常生活中接触的到的事物，然后感兴趣对其深入了解，对事物的诠释，录入词库方便日后检索 &gt; <a href="https://www.notion.so/dc80adb5-a54f-4b3f-851f-a856e22676a3" target="_blank" rel="noopener">WIKI</a></p><p>这个时候可能形成对事物更加深入的看法，比如当前这样的 对个人信息管理的看法记录成笔记 &gt; <a href="https://www.notion.so/caa783ee-ef0c-4a77-bc7a-ba4cba9c47c7" target="_blank" rel="noopener">即兴笔记</a></p><p>即 <code>词条</code> 对应 WIKI，对词条的<code>思考</code> 对应 即兴笔记，多条 即兴笔记 这里汇集成一篇输出成型的 blog</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>把思考写下来，将思考形式化，会发现，知识存在的一种结构性。例如当前这篇思考。</p><p>从 知识获取的形式 到 知识管理。 其实内在是一样的，只不过表述不同。</p><p>总体来说就是 input think output</p><p>输入的是<code>词汇</code> 过程中是对于词汇的<code>思考</code> 最后思考聚合沉淀变成吸收的<code>知识</code></p><p>如果想要获取知识，首先要给他一个名称，这个观点类似于，《写给大家看的设计书》中提到的观点</p><blockquote><p>很多年前的一个圣诞节，我收到一份圣诞礼物，是一本关于如何认识各种树的书。当时我住在父母家，所有礼物都打开后，我决定出去走走，认一认邻居家的树。出去之前我读了书的一部分。其中提到的第一种树是约书亚树，只需要两个线索就能认出它。由于约书亚树相当怪异，所以看到书中它的照片时，我对自己说：“哦，北加利福尼亚绝对没有这种树。这种树太怪异了。如果我见过，肯定应该有印象，可我以前从来没有见过。”</p></blockquote><blockquote><p>之后我拿着这本书走出家门。我的父母住在一个小巷子里，这里共有 6 家住户。其中 4 家的前院里都赫然立着约书亚树。我住在那里已经有 13 年了，此前居然从未注意过约书亚树。我在这个街区转了转，发现似乎每一家布置新居时都会到苗圃买约书亚树，至少 80% 的住家前院都种有约书亚树。而我在此之前居然从来没有注意过！在我知道了这种树之后，我是说在我能够说出它的名字后，它就无处不在了。这正是我要强调的：一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，让它受你所控。</p></blockquote><p>那么总结起来，获取知识的过程应该是这样的</p><ul><li>获取信息（过滤出来的有意义的信息），这个过程实际上是在获取关键字 get keyword</li><li>获取关键字的过程 实际上是在命名 name it</li><li>对关键字的诠释 desc</li><li>对关键字的思考 think</li><li>对思考的沉淀，产出，形成自己的知识  get it</li></ul><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><h3 id="命名的力量"><a href="#命名的力量" class="headerlink" title="命名的力量"></a>命名的力量</h3><p>我在上面提到的<code>词汇</code>、<code>关键字</code>。它们其实指的是同一个东西，如果你不能以统一的名称来称呼它们，就会发现很难构建出知识。</p><p>它们可能是近义的，所有你必须理解清楚，它们到底是不是同一个东西。否则在构建知识的过程中会产生混乱，混乱增多关于这个知识的构建就会崩塌。理解不够彻底</p><p>命名其实是一个确定唯一的过程，如果表达这个知识的近义词很多，而你又不理解，它们是否指代的是同一个东西。 用编程的思维来看，这个时候变量名混乱，code 可读性差，导致无法理解。</p><p>如果关于 这个知识的系统里面，有很多信息。在你完全没有掌握这个系统的时候，系统总是熵增的，即混乱的。理解的过程实际上是将，同义词、近义词的数量缩减的过程，这个时候熵减。混乱度降低就可以更好的理解。</p><p>实际上还是一个庖丁解牛的过程，细分，分类。脑袋就是一台机器，复杂的信息，必须要被拆分成简单的信息才能被理解。</p><h3 id="混乱与焦虑"><a href="#混乱与焦虑" class="headerlink" title="混乱与焦虑"></a>混乱与焦虑</h3><p>通过刚才的梳理，本来混乱不堪的notion，变得有条理。顿时感觉心里少了些焦虑。人们倾向于看到有条理的事物，这会使人愉悦。如果混乱不堪则提不起兴趣，无聊，当无聊累加到一定程度，就会产生焦虑。所以混乱是焦虑的源头？</p><p>写作是内在思考的逻辑体现，表达出来之后，可以对逻辑进行处理校正。这样信息会变得有条理。</p><p>所以写作是很重要的</p><h2 id="观点提炼"><a href="#观点提炼" class="headerlink" title="观点提炼"></a>观点提炼</h2><p>通过上面的思考，得出以下观点</p><ul><li>写作体现逻辑，更好的校正逻辑。</li><li>混乱产生焦虑</li><li>命名减少熵增</li><li>知识形成的过程：获取信息》提出词汇》获取释义》思考》沉淀产出</li><li>同上对应的形式：RSS》WIKI》即兴笔记》Blog</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;个人信息管理&quot;&gt;&lt;a href=&quot;#个人信息管理&quot; class=&quot;headerlink&quot; title=&quot;个人信息管理&quot;&gt;&lt;/a&gt;个人信息管理&lt;/h1&gt;&lt;p&gt;关于个人信息管理流程的思考&lt;/p&gt;
&lt;h2 id=&quot;知识的获取&quot;&gt;&lt;a href=&quot;#知识的获取&quot;
        
      
    
    </summary>
    
    
      <category term="信息管理" scheme="https://blog.gine.me/tags/%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/"/>
    
      <category term="效率" scheme="https://blog.gine.me/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
